{% extends "base.html" %}{% block content %}
<h2>{{ object.part_no }} {{ object.revision }}</h2>
<p>Units: {{ object.units }} • Mode: {{ object.abs_mode|yesno:"ABS,INC" }}</p>
<p>BBox: {{ object.bbox_json }} • Est: {{ object.est_time_s|floatformat:1 }} s</p>

<a class="btn" href="{% url 'job_new_for_program' object.pk %}">Create Job</a>

{% if object.meta_json.lints %}
  <h3>Warnings</h3>
  <ul>
    {% for l in object.meta_json.lints %}
      <li>{{ l.code }} — {{ l.msg }}</li>
    {% endfor %}
  </ul>
{% endif %}

<!-- ===== 2D VIEWER CONTROLS ===== -->
<div style="margin:.75rem 0; display:flex; gap:1rem; align-items:center; flex-wrap:wrap">
  <label><input id="tog-rapids" type="checkbox" checked> Show rapids</label>
  <label><input id="tog-grid" type="checkbox" checked> Show grid</label>
  <label>Progress <input id="scrub" type="range" min="0" max="100" value="100" style="vertical-align:middle"></label>
  <button id="reset" class="btn" type="button">Reset view</button>
</div>

<!-- ===== 2D VIEWER CANVAS ===== -->
<canvas id="plot" width="900" height="600"
  style="background:#0b1220;border:1px solid #1f2937"
  aria-label="Toolpath preview"></canvas>

<script>
(async ()=>{
  const res = await fetch("{% url 'program_preview_json' object.pk %}");
  const {segments,bbox} = await res.json();

  const c = document.getElementById('plot'), ctx = c.getContext('2d');
  const showRapids = document.getElementById('tog-rapids');
  const showGrid   = document.getElementById('tog-grid');
  const scrub      = document.getElementById('scrub');
  const resetBtn   = document.getElementById('reset');

  const m=20; // margin
  const w=c.width-2*m, h=c.height-2*m;
  const sx=Math.max(1e-9, bbox.xmax-bbox.xmin),
        sy=Math.max(1e-9, bbox.ymax-bbox.ymin);

  // view transform state
  const baseScale = 0.9*Math.min(w/sx, h/sy);
  let zoom = 1.0, panX = 0.0, panY = 0.0;

  function toScreen(x,y){
    const X = m + ((x - bbox.xmin)*baseScale*zoom + panX);
    const Y = c.height - (m + ((y - bbox.ymin)*baseScale*zoom + panY));
    return [X,Y];
  }
  function worldStep(){
    const vr = Math.max(sx, sy) / zoom;
    const raw = vr/10;
    const pow = Math.pow(10, Math.floor(Math.log10(raw)));
    const m2 = raw/pow < 2 ? 1 : raw/pow < 5 ? 2 : 5;
    return m2 * pow;
  }

  function draw(){
    ctx.clearRect(0,0,c.width,c.height);

    // frame
    ctx.strokeStyle="#334155";
    ctx.lineWidth=1; ctx.setLineDash([]);
    ctx.strokeRect(m,m,w,h);

    // grid
    if(showGrid.checked){
      const step = worldStep();
      ctx.lineWidth=1; ctx.setLineDash([]);
      ctx.strokeStyle="#1f2937";
      for(let gx=Math.ceil(bbox.xmin/step)*step; gx<=bbox.xmax; gx+=step){
        const [x1,y1]=toScreen(gx,bbox.ymin), [x2,y2]=toScreen(gx,bbox.ymax);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      }
      for(let gy=Math.ceil(bbox.ymin/step)*step; gy<=bbox.ymax; gy+=step){
        const [x1,y1]=toScreen(bbox.xmin,gy), [x2,y2]=toScreen(bbox.xmax,gy);
        ctx.beginPath(); ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
      }
    }

    // toolpath (scrub)
    const pct = parseInt(scrub.value,10)/100;
    const N = Math.max(0, Math.min(segments.length, Math.floor(segments.length*pct)));
    for(let i=0;i<N;i++){
      const s = segments[i];
      if(s.k==="G0" && !showRapids.checked) continue;
      const [x1,y1] = toScreen(s.frm[0], s.frm[1]);
      const [x2,y2] = toScreen(s.to[0],  s.to[1]);
      ctx.beginPath();
      ctx.moveTo(x1,y1); ctx.lineTo(x2,y2);
      ctx.lineWidth = s.k==="G0"?1:2;
      ctx.setLineDash(s.k==="G0"?[4,4]:[]);
      ctx.strokeStyle = s.k==="G0" ? "#64748b" : "#60a5fa";
      ctx.stroke();
    }
  }

  // zoom around mouse
  c.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const rect = c.getBoundingClientRect();
    const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
    const wx = ((cx - m) - panX)/(baseScale*zoom) + bbox.xmin;
    const wy = ((c.height - cy - m) - panY)/(baseScale*zoom) + bbox.ymin;
    const factor = e.deltaY < 0 ? 1.1 : 0.9;
    zoom = Math.max(0.1, Math.min(10, zoom*factor));
    panX = (cx - m) - (wx - bbox.xmin)*baseScale*zoom;
    panY = (c.height - cy - m) - (wy - bbox.ymin)*baseScale*zoom;
    draw();
  }, {passive:false});

  // pan with drag
  let dragging=false, lastX=0, lastY=0;
  c.addEventListener('mousedown', e=>{ dragging=true; lastX=e.clientX; lastY=e.clientY; });
  window.addEventListener('mouseup', ()=>{ dragging=false; });
  window.addEventListener('mousemove', e=>{
    if(!dragging) return;
    const dx=e.clientX-lastX, dy=e.clientY-lastY;
    panX += dx; panY -= dy; // invert y
    lastX=e.clientX; lastY=e.clientY;
    draw();
  });

  resetBtn.addEventListener('click', ()=>{ zoom=1; panX=0; panY=0; draw(); });
  showRapids.addEventListener('change', draw);
  showGrid.addEventListener('change', draw);
  scrub.addEventListener('input', draw);

  draw();
})();
</script>

<!-- ===== 3D VIEWER ===== -->
<h3 style="margin-top:1rem">3D View</h3>
<div id="view3d" style="width:100%;height:520px;background:#0b1220;border:1px solid #1f2937"></div>
<div style="margin:.5rem 0;display:flex;gap:1rem;align-items:center;flex-wrap:wrap">
  <label><input id="show-rapids" type="checkbox" checked> Show rapids</label>
  <label><input id="show-cuts"   type="checkbox" checked> Show cuts</label>
  <label><input id="show-grid"   type="checkbox" checked> Show grid</label>
  <label><input id="show-box"    type="checkbox" checked> Show bbox</label>
  <label>Progress <input id="scrub3d" type="range" min="0" max="100" value="100"></label>
  <button id="reset3d" class="btn" type="button">Reset view</button>
</div>

<!-- Import map so OrbitControls can import "three" -->
<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
    "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.158.0/examples/jsm/controls/OrbitControls.js"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

(async () => {
  // ---- fetch data
  const resp = await fetch("{% url 'program_preview_json' object.pk %}");
  const data = await resp.json();
  const segs = data.segments3d || [];
  let bb   = data.bbox_mm || { xmin:0, xmax:0, ymin:0, ymax:0, zmin:0, zmax:0 };

  // compute bbox from segments if server bbox is degenerate
  const deg = b => (b.xmax-b.xmin===0)&&(b.ymax-b.ymin===0)&&(b.zmax-b.zmin===0);
  if (segs.length && deg(bb)) {
    const b = { xmin:Infinity,xmax:-Infinity,ymin:Infinity,ymax:-Infinity,zmin:Infinity,zmax:-Infinity };
    for (const s of segs) for (const p of [s.frm, s.to]) {
      b.xmin=Math.min(b.xmin,p[0]); b.xmax=Math.max(b.xmax,p[0]);
      b.ymin=Math.min(b.ymin,p[1]); b.ymax=Math.max(b.ymax,p[1]);
      b.zmin=Math.min(b.zmin,p[2]); b.zmax=Math.max(b.zmax,p[2]);
    }
    if (isFinite(b.xmin)) bb = b;
  }

  // ---- scene
  const el = document.getElementById("view3d");
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(el.clientWidth, el.clientHeight);
  el.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x0b1220);

  const cx=(bb.xmin+bb.xmax)/2, cy=(bb.ymin+bb.ymax)/2, cz=(bb.zmin+bb.zmax)/2;
  const spanX=Math.max(1e-3, bb.xmax-bb.xmin);
  const spanY=Math.max(1e-3, bb.ymax-bb.ymin);
  const spanZ=Math.max(1e-3, bb.zmax-bb.zmin);
  const span=Math.max(spanX, spanY, spanZ, 100);

  const camera = new THREE.PerspectiveCamera(45, el.clientWidth/el.clientHeight, 0.1, 10000);
  camera.position.set(cx + span*1.5, cy - span*1.5, cz + span*1.5);

  const controls = new OrbitControls(camera, renderer.domElement);
  controls.target.set(cx, cy, cz);
  controls.update();

  // helpers
  const axes = new THREE.AxesHelper(Math.max(50, span*0.6));
  scene.add(axes);

  const gridSize = Math.pow(10, Math.ceil(Math.log10(span))) || 100;
  const grid = new THREE.GridHelper(gridSize, 20, 0x263244, 0x1f2937);
  grid.rotation.x = Math.PI/2;
  grid.position.z = bb.zmin || 0;
  scene.add(grid);

  // bbox helper (toggle-able if you keep a ref)
  let boxHelper = null;
  if (!deg(bb)) {
    const box3 = new THREE.Box3(
      new THREE.Vector3(bb.xmin, bb.ymin, bb.zmin),
      new THREE.Vector3(bb.xmax, bb.ymax, bb.zmax)
    );
    boxHelper = new THREE.Box3Helper(box3, new THREE.Color(0x334155));
    scene.add(boxHelper);
  }

  // ---- lines + scrub support ----------------------------------------------
  let rapidLines = null, cutLines = null;

  function updateGeometries(pct){
    const upto = Math.max(0, Math.min(segs.length, Math.floor(segs.length * pct)));
    const rapidsPos = [];
    const cutsPos   = [];
    for(let i=0;i<upto;i++){
      const s = segs[i];
      const arr = (s.k==="G0" || s.k==="G00") ? rapidsPos : cutsPos;
      arr.push(s.frm[0], s.frm[1], s.frm[2], s.to[0], s.to[1], s.to[2]);
    }

    // helper to (re)build a LineSegments' geometry while reusing material
    function rebuild(mesh, positions, colorHex){
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      if (mesh){
        mesh.geometry.dispose();
        mesh.geometry = geo;
        return mesh;
      } else {
        const mat = new THREE.LineBasicMaterial({ color: colorHex });
        return new THREE.LineSegments(geo, mat);
      }
    }

    rapidLines = rebuild(rapidLines, rapidsPos, 0x64748b);
    cutLines   = rebuild(cutLines,   cutsPos,   0x60a5fa);

    if (!scene.children.includes(rapidLines)) scene.add(rapidLines);
    if (!scene.children.includes(cutLines))   scene.add(cutLines);
  }

  // initial full draw
  updateGeometries(1.0);

  // ---- UI wiring -----------------------------------------------------------
  const togRapids = document.getElementById("show-rapids");
  const togCuts   = document.getElementById("show-cuts");
  const togGrid   = document.getElementById("show-grid");
  const togBox    = document.getElementById("show-box");
  const scrub3d   = document.getElementById("scrub3d");
  const resetBtn  = document.getElementById("reset3d");

  if (togRapids) togRapids.addEventListener("change", ()=> rapidLines && (rapidLines.visible = togRapids.checked));
  if (togCuts)   togCuts.addEventListener("change",   ()=> cutLines   && (cutLines.visible   = togCuts.checked));
  if (togGrid)   togGrid.addEventListener("change",   ()=> grid.visible = togGrid.checked);
  if (togBox && boxHelper) togBox.addEventListener("change", ()=> boxHelper.visible = togBox.checked);
  if (scrub3d)  scrub3d.addEventListener("input", ()=> updateGeometries(parseInt(scrub3d.value,10)/100));
  if (resetBtn) resetBtn.addEventListener("click", ()=>{
    camera.position.set(cx + span*1.5, cy - span*1.5, cz + span*1.5);
    controls.target.set(cx, cy, cz); controls.update();
  });

  // ---- resize & render -----------------------------------------------------
  window.addEventListener("resize", ()=>{
    const w = el.clientWidth, h = el.clientHeight;
    renderer.setSize(w, h);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  });

  (function animate(){ requestAnimationFrame(animate); renderer.render(scene, camera); })();
})();
</script>
{% endblock %}